name: "Turing"
scopeName: "source.turing"
fileTypes: [".t", ".tu"]
patterns: [include: "#main"]

repository:
	
	# Common patterns
	main:
		patterns: [
			{ include: "#comments"      }
			{ include: "#boolean"       }
			{ include: "#string"        }
			{ include: "#numbers"       }
			{ include: "#for"           }
			{ include: "#cc"            }
			{ include: "#case"          }
			{ include: "#function"      }
			{ include: "#keywords"      }
			{ include: "#variables"     }
			{ include: "#operators"     }
			{ include: "#procedure"     }
			{ include: "#process"       }
			{ include: "#class"         }
			{ include: "#function-call" }
		]


	# Comments
	comments:
		patterns: [{
			
			# End-of-line comment
			name: "comment.line.percentage.turing"
			begin: "%"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.definition.comment.turing"
		},{
			
			# Bracketed
			name: "comment.block.bracketed.turing"
			begin: "/\\*"
			end: "\\*/"
			beginCaptures: 0: name: "punctuation.definition.comment.turing"
			endCaptures:   0: name: "punctuation.definition.comment.turing"
		}]

	
	
	# String literals
	string:
		name: "string.quoted.double.turing"
		begin: '"'
		end:   '"'
	
	
	# Numbers
	numbers:
		patterns: [
			{name: "constant.numeric.float.turing", match: "\\b\\d+\\.\\d+\\b"}
			{name: "constant.numeric.int.turing",   match: "\\b\\d+\\b"}
		]
	
	
	# List of named values
	list:
		patterns: [
			{match: "\\w+", name: "variable.name.turing"}
			{match: ",",    name: "meta.delimiter.object.comma.turing"}
		]
	
	
	# Function declaration
	function:
		name: "meta.function.turing"
		begin: """(?x)
			\\b
			(?:
				(body)          # 1: storage.modifier.body.turing
				\\s+
			)?
			(function|fcn)      # 2: storage.type.turing
			(?:
				\\s+
				(pervasive|\\*) # 3: storage.modifier.pervasive.turing
			)?
			\\s+
			(\\w+)              # 4: entity.name.function.turing
			\\s*
			(                   # 5: meta.function.parameters.turing
				(\\()           # 6: punctuation.definition.parameters.begin.turing
				(.*)            # 7: include: “#param-declarations”
				(\\))           # 8: punctuation.definition.parameters.end.turing
			)
			\\s*
			(:)                 # 9: punctuation.separator.key-value.turing
			\\s*
			(\\w+)              # 10: storage.type.type-spec.turing
		"""
		end: "\\b(end)\\s+(\\4)"
		patterns: [{
			
			# pre|init|post clause
			name: "meta.$1-function.turing"
			begin: "^\\s*(pre|init|post)(?=\\s|$)"
			end: "$"
			patterns: [include: "$self"]
			beginCaptures:
				1: name: "keyword.function.$1.turing"
		
			},{ include: "$self" }
		]
		beginCaptures:
			1: name: "storage.modifier.body.turing"
			2: name: "storage.type.turing"
			3: name: "storage.modifier.pervasive.turing"
			4: name: "entity.name.function.turing"
			5: name: "meta.function.parameters.turing"
			6: name: "punctuation.definition.parameters.begin.turing"
			7: patterns: [include: "#param-declarations"]
			8: name: "punctuation.definition.parameters.end.turing"
			9: name: "punctuation.separator.key-value.turing"
			10: name: "storage.type.type-spec.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "entity.name.function.turing"


	# Function parameters
	"param-declarations":
		match: "\\b(\\w+)\\s+(:)\\s+((\\w+))"
		captures:
			1: name: "variable.parameter.function.turing"
			2: name: "storage.type.turing"
			3: patterns: [include: "#types"]


	# Function call
	"function-call":
		name: "meta.function-call.turing"
		begin: "(([\\w.]+))\\s*(\\()"
		end:   "\\)"
		contentName: "meta.function-call.arguments.turing"
		beginCaptures:
			1: name: "entity.function.name.turing"
			2: patterns: [match: "\\.", name: "punctuation.separator.method.turing"]
			3: name: "punctuation.definition.arguments.begin.turing"
		endCaptures:
			0: name: "punctuation.definition.arguments.end.turing"
		patterns: [include: "$self"]
		
	
	# Keywords
	keywords:
		patterns: [{
			
			# Control flow
			match: "\\b((?:end\\s+)?if|then|elsif|else|(?:end\\s+)?loop|exit|when)\\b"
			name: "keyword.control.$1.turing"
		},{
			
			# Logical operators
			match: "\\b(and|not|x?or)\\b"
			name: "keyword.operator.$1.turing"
		},{
			
			# Statements
			match: "\\b(assert|begin|break|close|exit|fork|free|get|new|open|pause|put|quit|read|result|return|seek|signal|tag|tell|wait|write)\\b"
			name: "keyword.other.statement.$1.turing"
		},{
			
			# Modifiers
			match: "\\b(monitor)\\b"
			name: "storage.modifier.$1.turing"
		},{
		
			# Skip (used in get/put statements)
			match: "\\b(skip)\\b"
			name: "constant.language.skip.turing"
		}]


	# Conditional compilation
	cc:
		name: "meta.preprocessor.$3.turing"
		match: "^\\s*((#)((?:end\\s+)?if|elsif|else))"
		captures:
			1: name: "keyword.control.directive.conditional.turing"		
			2: name: "punctuation.definition.directive.turing"


	# For loops
	for:
		name: "meta.for-loop.turing"
		begin: "\\b(for)\\b(?:\\s+(decreasing)\\b)?"
		end:   "\\b(end)\\s+(for)"
		patterns: [
			{
				match: "\\G(.*?)\\b(by)\\b"
				captures:
					1: patterns: [include: "$self"]
					2: name: "keyword.control.by.turing"
			
			},{include: "$self"}
		]
		beginCaptures:
			1: name: "keyword.control.for.turing"
			2: name: "keyword.operator.decreasing.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "keyword.control.for.turing"

	
	# Case blocks
	case:
		name: "meta.scope.case-block.turing"
		begin: "\\b(case)\\s+(\\w+)\\s+(of)\\b"
		end:   "\\b(end\\s+case)\\b"
		patterns: [
			{match: "\\b(label)\\b", name: "keyword.other.statement.label"}
			{include: "$self"}
		]
		beginCaptures:
			1: name: "keyword.control.case.turing"
			2: name: "variable.parameter.turing"
			3: name: "keyword.operator.of.turing"
		endCaptures:
			1: name: "keyword.control.end.case.turing"


	# Procedure declaration
	procedure:
		name: "meta.scope.$1.procedure.turing"
		begin: "\\b(?:(deferred|body)\\s+)?(procedure|proc)\\s+(\\w+)"
		end:   "\\b(end)\\s+(\\3)"
		patterns: [
			{include: "#parameters"}
			{include: "$self"}
		]
		beginCaptures:
			1: name: "storage.modifier.$1.turing"
			2: name: "storage.type.function.turing"
			3: name: "entity.name.function.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "entity.name.function.turing"
	
	
	# Process statement
	process:
		name: "meta.scope.process.turing"
		begin: "\\b(process)(?:\\s+(pervasive|\\*)(?=\\s))?\\s+(\\w+)"
		end:   "\\b(end)\\s+(\\3)"
		patterns: [
			{include: "#parameters"}
			{include: "$self"}
		]
		beginCaptures:
			1: name: "storage.type.function.turing"
			2: name: "storage.modifier.pervasive.turing"
			3: name: "entity.name.function.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "entity.name.function.turing"
	
	
	# Bracketed parameter blocks used in procedure/process definitions
	parameters:
		name: "meta.function.parameters.turing"
		begin: "\\G\\s*(\\()"
		end: "\\)"
		beginCaptures: 1: name: "punctuation.definition.arguments.begin.turing"
		endCaptures:   0: name: "punctuation.definition.arguments.end.turing"
		patterns: [
			{include: "$self"}
			{match: "\\w+", name: "variable.parameter.function.turing"}
		]
	
	
	# Class declarations
	class:
		name: "meta.scope.class-block.turing"
		begin: "^\\s*(class)\\s+(\\w+)"
		end:   "\\b(end)\\s+(\\2)"
		patterns: [
			{include: "#class-innards"}
			{include: "$self"}
		]
		beginCaptures:
			1: name: "storage.type.class.turing"
			2: name: "entity.name.type.class.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "entity.name.type.class.turing"
	
	
	# Various clauses for inheritance, importing/exporting, etc
	"class-innards":
		patterns: [{
			
			# Import/export
			begin: "\\b(import|export)\\b"
			end:   "(?=$|%|/\\*)"
			beginCaptures:
				1: name: "keyword.control.$1.turing"
			patterns: [
				{include: "#list"}
				{include: "$self"}
			]
		},{
			
			# Inherited class
			name: "meta.other.inherited-class.turing"
			begin: "\\b(inherit)\\b"
			end:   "\\w+"
			beginCaptures: 1: name: "storage.modifier.inherit.turing"
			endCaptures:   0: name: "entity.other.inherited-class.turing"
			patterns: [include: "$self"]
		},{
			
			# Implement/Implement by
			name: "meta.other.$1.turing"
			begin: "\\b(implement(?:\\s+by)?)\\b"
			end:   "\\w+"
			beginCaptures: 1: name: "storage.modifier.implements.turing"
			endCaptures:   0: name: "entity.other.inherited-class.turing"
			patterns: [include: "$self"]
		}]
	

	# Variables
	variables:
		patterns: [{
			
			# Declaration
			name: "meta.variable-declaration.turing"
			begin: "\\b(var)\\s+"
			end:   "(:)\\s*(\\w*)\\s*(:=)?"
			beginCaptures:
				1: name: "storage.type.$1.turing"
			endCaptures:
				1: name: "punctuation.separator.key-value.turing"
				2: name: "storage.type.type-spec.turing"
				3: name: "punctuation.separator.key-value.turing"
			patterns: [
				
				# Object-oriented Turing: Additional keywords
				{
					match: "\\G(?:\\s*(pervasive|\\*)(?=\\s))?\\s*(register)(?=\\s)"
					captures:
						1: name: "storage.modifier.pervasive.oot.turing"
						2: name: "storage.modifier.register.oot.turing"
				}
				
				# Variable names
				{include: "#list"}
			]
		},{
			
			# Assignment
			name: "meta.variable-assignment.turing"
			begin: "(\\w+)\\s*(:=)"
			end: "(?=\\S)"
			beginCaptures:
				1: name: "variable.name.turing"
				2: name: "punctuation.separator.key-value.turing"
		}]

	
	# Boolean values
	boolean:
		name: "constant.language.boolean.$1.turing"
		match: "\\b(true|false)\\b"
	
	
	# Arithmetic/Punctuation-based operators
	operators:
		patterns: [
			{match: "\\.\\.",  name: "punctuation.definition.range.turing"}
			{match: ":=",      name: "punctuation.separator.key-value.assignment.turing"}
			{match: "->",      name: "punctuation.separator.class.accessor.turing"}
			{match: "\\+",     name: "keyword.operator.arithmetic.add.turing"}
			{match: "-",       name: "keyword.operator.arithmetic.subtract.turing"}
			{match: "\\*",     name: "keyword.operator.arithmetic.multiply.turing"}
			{match: "\\\\",    name: "keyword.operator.arithmetic.divide.turing"}
			{match: "<=",      name: "keyword.operator.logical.equal-or-less.subset.turing"}
			{match: ">=",      name: "keyword.operator.logical.equal-or-greater.superset.turing"}
			{match: "<",       name: "keyword.operator.logical.less.turing"}
			{match: ">",       name: "keyword.operator.logical.greater.turing"}
			{match: "=",       name: "keyword.operator.logical.equal.turing"}
			{match: "not=|~=", name: "keyword.operator.logical.not.turing"}
			{match: ":",       name: "punctuation.separator.key-value.turing"}
		]
