name: "Turing"
scopeName: "source.turing"
fileTypes: [".t", ".tu"]
patterns: [include: "#main"]

repository:
	
	# Common patterns
	main:
		patterns: [
			{ include: "#comments"      }
			{ include: "#boolean"       }
			{ include: "#string"        }
			{ include: "#numbers"       }
			{ include: "#for"           }
			{ include: "#function"      }
			{ include: "#keywords"      }
			{ include: "#variables"     }
			{ include: "#operators"     }
			{ include: "#function-call" }
		]


	# Comments
	comments:
		patterns: [{
			
			# End-of-line comment
			name: "comment.line.percentage.turing"
			begin: "%"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.definition.comment.turing"
		},{
			
			# Bracketed
			name: "comment.block.bracketed.turing"
			begin: "/\\*"
			end: "\\*/"
			beginCaptures: 0: name: "punctuation.definition.comment.turing"
			endCaptures:   0: name: "punctuation.definition.comment.turing"
		}]

	
	
	# String literals
	string:
		name: "string.quoted.double.turing"
		begin: '"'
		end:   '"'
	
	
	# Numbers
	numbers:
		patterns: [
			{name: "constant.numeric.float.turing", match: "\\b\\d+\\.\\d+\\b"}
			{name: "constant.numeric.int.turing",   match: "\\b\\d+\\b"}
		]
	
	
	# Function declaration
	function:
		name: "meta.function.turing"
		begin: """(?x)
			\\b
			(function|fcn)  # 1: storage.type.turing
			(?:
				\\s+
				(pervasive) # 2: storage.modifier.pervasive.turing
			)?
			\\s+
			(\\w+)          # 3: entity.name.function.turing
			\\s+
			(               # 4: meta.function.parameters.turing
				(\\()       # 5: punctuation.definition.parameters.begin.turing
				(.*)        # 6: include: “#param-declarations”
				(\\))       # 7: punctuation.definition.parameters.end.turing
			)
			\\s*
			(:)             # 8: punctuation.separator.key-value.turing
			\\s*
			(\\w+)          # 9: storage.type.type-spec.turing
		"""
		end: "\\b(end)\\s+(\\3)"
		patterns: [{
			
			# pre|init|post clause
			name: "meta.$1-function.turing"
			begin: "^\\s*(pre|init|post)(?=\\s|$)"
			end: "$"
			patterns: [include: "$self"]
			beginCaptures:
				1: name: "keyword.function.$1.turing"
		
			},{ include: "$self" }
		]
		beginCaptures:
			1: name: "storage.type.turing"
			2: name: "storage.modifier.pervasive.turing"
			3: name: "entity.name.function.turing"
			4: name: "meta.function.parameters.turing"
			5: name: "punctuation.definition.parameters.begin.turing"
			6: patterns: [include: "#param-declarations"]
			7: name: "punctuation.definition.parameters.end.turing"
			8: name: "punctuation.separator.key-value.turing"
			9: name: "storage.type.type-spec.turing"
		endCaptures:
			1: name: "keyword.control.end.turing"
			2: name: "entity.name.function.turing"


	# Function parameters
	"param-declarations":
		match: "\\b(\\w+)\\s+(:)\\s+((\\w+))"
		captures:
			1: name: "variable.parameter.function.turing"
			2: name: "storage.type.turing"
			3: patterns: [include: "#types"]


	# Function call
	"function-call":
		name: "meta.function-call.turing"
		begin: "(([\\w.]+))\\s*(\\()"
		end:   "\\)"
		contentName: "meta.function-call.arguments.turing"
		beginCaptures:
			1: name: "entity.function.name.turing"
			2: patterns: [match: "\\.", name: "punctuation.separator.method.turing"]
			3: name: "punctuation.definition.arguments.begin.turing"
		endCaptures:
			0: name: "punctuation.definition.arguments.end.turing"
		patterns: [include: "$self"]
		
	
	# Keywords
	keywords:
		patterns: [{
			
			# Control flow
			match: "\\b((?:end\\s+)?if|then|elsif|else|(?:end\\s+)?loop|exit|when)\\b"
			name: "keyword.control.$1.turing"
		
		},{
			# Logical operators
			match: "\\b(and|not|x?or)\\b"
			name: "keyword.operator.$1.turing"
		}]


	# For loops
	for:
		patterns: [{
			name: "meta.for-loop.turing"
			begin: "\\b(for)\\b(?:\\s+(decreasing)\\b)?"
			end:   "\\b(end)\\s+(for)"
			patterns: [
				{
					match: "\\G(.*?)\\b(by)\\b"
					captures:
						1: patterns: [include: "$self"]
						2: name: "keyword.control.by.turing"
				
				},{include: "$self"}
			]
			beginCaptures:
				1: name: "keyword.control.for.turing"
				2: name: "keyword.operator.decreasing.turing"
			endCaptures:
				1: name: "keyword.control.end.turing"
				2: name: "keyword.control.for.turing"
		}]


	# Variable assignments
	variables:
		name: "meta.variable.assignment.turing"
		begin: "^\\s*(var)\\s+"
		end:   "(:)\\s*(\\w*)\\s*(:=)?"
		beginCaptures:
			1: name: "storage.type.$1.turing"
		endCaptures:
			1: name: "punctuation.separator.key-value.turing"
			2: name: "storage.type.type-spec.turing"
			3: name: "punctuation.separator.key-value.turing"
		patterns: [{
			
			# Object-oriented Turing: Additional keywords
			match: "\\G(?:\\s*(pervasive|\\*)(?=\\s))?\\s*(register)(?=\\s)"
			captures:
				1: name: "storage.modifier.pervasive.oot.turing"
				2: name: "storage.modifier.register.oot.turing"
		}]

	
	# Boolean values
	boolean:
		name: "constant.language.boolean.$1.turing"
		match: "\\b(true|false)\\b"
	
	
	# Arithmetic/Punctuation-based operators
	operators:
		patterns: [
			{match: "\\.\\.",  name: "punctuation.definition.range.turing"}
			{match: ":=",      name: "punctuation.separator.key-value.assignment.turing"}
			{match: "\\+",     name: "keyword.operator.arithmetic.add.turing"}
			{match: "-",       name: "keyword.operator.arithmetic.subtract.turing"}
			{match: "\\*",     name: "keyword.operator.arithmetic.multiply.turing"}
			{match: "\\\\",    name: "keyword.operator.arithmetic.divide.turing"}
			{match: "<=",      name: "keyword.operator.logical.equal-or-less.subset.turing"}
			{match: ">=",      name: "keyword.operator.logical.equal-or-greater.superset.turing"}
			{match: "<",       name: "keyword.operator.logical.less.turing"}
			{match: ">",       name: "keyword.operator.logical.greater.turing"}
			{match: "=",       name: "keyword.operator.logical.equal.turing"}
			{match: "not=|~=", name: "keyword.operator.logical.not.turing"}
			{match: ":",       name: "punctuation.separator.key-value.turing"}
		]
